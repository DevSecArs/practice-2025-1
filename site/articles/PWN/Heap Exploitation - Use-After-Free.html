<article class="markdown-body entry-content container-lg" itemprop="text">
 <div class="markdown-heading" dir="auto">
  <h1 class="heading-element" dir="auto" tabindex="-1">
   Heap Exploitation: Use-After-Free (UAF)
  </h1>
 </div>
 <div class="markdown-heading" dir="auto">
  <h2 class="heading-element" dir="auto" tabindex="-1">
   Введение
  </h2>
 </div>
 <p dir="auto">
  <strong>
   Use-After-Free
  </strong>
  представляет собой одну из наиболее интересных и в то же время опасных
        уязвимостей, связанных с эксплуатацией кучи. Для её понимания и успешного использования необходимо глубокое
        знание механики работы аллокатора памяти, структуры чанков и особенностей поведения аллокаций при различных
        сценариях. Несмотря на техническую сложность, такие уязвимости открывают широкие возможности для нестандартных
        атак и оригинальных способов захвата управления программой.
 </p>
 <p dir="auto">
  Инструменты вроде
  <strong>
   GDB
  </strong>
  и расширения
  <strong>
   pwndbg
  </strong>
  позволяют детально
        анализировать поведение программы на этапе выполнения, отслеживать движения по куче, находить утечки и точно
        определять, где именно происходит ошибка.
 </p>
 <div class="markdown-heading" dir="auto">
  <h2 class="heading-element" dir="auto" tabindex="-1">
   Что такое UAF?
  </h2>
 </div>
 <p dir="auto">
  <strong>
   Use-After-Free (UAF)
  </strong>
  — это уязвимость, связанная с ошибками управления динамически
        выделенной памятью. Она возникает в тех случаях, когда программа сначала корректно выделяет блок памяти, затем
        освобождает его, но по каким-то причинам продолжает использовать указатель на уже освобождённую область. Такая
        ошибка характерна прежде всего для языков низкого уровня, таких как C и C++, где управление памятью полностью
        возложено на программиста и не сопровождается встроенной защитой со стороны среды выполнения.
 </p>
 <p dir="auto">
  После освобождения памяти с помощью функций вроде
  <code>
   free()
  </code>
  в C или оператора
  <code>
   delete
  </code>
  в C++, сама память не обязательно немедленно очищается или перезаписывается. Более того,
        указатель на освобождённый блок остаётся валидным с точки зрения синтаксиса программы, что и делает уязвимость
        трудноуловимой без специальных инструментов или защиты на уровне компилятора и рантайма. На практике это
        означает, что программа может продолжать считывать или записывать данные в область памяти, которая уже может
        быть возвращена аллокатором и заново использована для хранения других объектов. В такой ситуации поведение
        становится неопределённым: от простого сбоя исполнения до серьёзных нарушений безопасности.
 </p>
 <p dir="auto">
  В некоторых случаях продолжение работы с освобождённой памятью приводит к так называемым
  <strong>
   "dangling pointers"
  </strong>
  — висячим указателям, которые ссылаются на устаревшие, уже
        перераспределённые участки памяти. Эти участки могут быть в дальнейшем перезаписаны новым содержимым, и если
        программа продолжит использовать старый указатель, она либо столкнётся с повреждением данных, либо получит
        доступ к чужим структурам, что может быть использовано злоумышленником в целях атаки.
 </p>
 <p dir="auto">
  Опасность
  <strong>
   UAF
  </strong>
  заключается в том, что она даёт возможность контролировать поведение
        программы через вмешательство в структуру кучи. Например, если атакующий сумеет предсказать или повлиять на то,
        какие данные будут размещены в ранее освобождённой области, он сможет подменить содержимое памяти, а при
        определённых условиях — даже вызвать выполнение произвольного кода. Такие атаки нередко приводят к компрометации
        всей системы, особенно если
  <strong>
   UAF
  </strong>
  эксплуатируется в программах с повышенными привилегиями или в
        ядре операционной системы.
 </p>
 <p dir="auto">
  На практике
  <strong>
   UAF
  </strong>
  может проявляться по-разному: от тривиального обращения к уже
        несуществующей строке до сложных сценариев переписывания таблиц виртуальных функций
  <code>
   (vtable)
  </code>
  , хуков
        и других чувствительных структур в памяти. В контексте реальной эксплуатации особенно интересны случаи, когда
  <strong>
   UAF
  </strong>
  даёт возможность обойти защитные механизмы вроде
  <strong>
   ASLR (Address Space Layout
            Randomization)
  </strong>
  ,
  <strong>
   tcache
  </strong>
  , или даже использовать его в комбинации с другими
        уязвимостями, такими как
  <strong>
   heap overflow
  </strong>
  или
  <strong>
   double free
  </strong>
  , создавая целые цепочки
        эксплуатации.
 </p>
 <p dir="auto">
  Таким образом, понимание механики
  <strong>
   UAF
  </strong>
  — это не просто знание о том, что «нельзя
        использовать указатель после
  <code>
   free()
  </code>
  ». Это целый пласт знаний о том, как работает менеджер памяти в
        операционных системах, как устроены аллокаторы, как защита памяти может быть обойдена и каким образом
        программное поведение может быть детерминировано и направлено атакующим.
 </p>
 <div class="markdown-heading" dir="auto">
  <h2 class="heading-element" dir="auto" tabindex="-1">
   Пример Use-After-Free
  </h2>
 </div>
 <p dir="auto">
  Рассмотрим простой пример программы на C с уязвимостью типа
  <strong>
   Use-After-Free
  </strong>
  . В этом
        примере можно наблюдать, как повторное использование освобождённой памяти без зануления указателя приводит к
        неожиданному поведению и потенциальной ошибке безопасности.
 </p>
 <div class="highlight highlight-source-c notranslate position-relative overflow-auto" dir="auto">
  <pre><span class="pl-k">#include</span> <span class="pl-s">&lt;stdio.h&gt;</span>
    <span class="pl-k">#include</span> <span class="pl-s">&lt;stdlib.h&gt;</span>
    <span class="pl-k">#include</span> <span class="pl-s">&lt;string.h&gt;</span>
    <span class="pl-k">#include</span> <span class="pl-s">&lt;unistd.h&gt;</span>
    
    <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-s1">notes</span>[<span class="pl-c1">8</span>];
    
    <span class="pl-smi">void</span> <span class="pl-en">add_note</span>() {
        <span class="pl-smi">int</span> <span class="pl-s1">idx</span>;
        <span class="pl-k">for</span> (<span class="pl-s1">idx</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">idx</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">8</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>]; <span class="pl-s1">idx</span><span class="pl-c1">++</span>);
        <span class="pl-k">if</span> (<span class="pl-s1">idx</span> <span class="pl-c1">==</span> <span class="pl-c1">8</span>) {
            <span class="pl-en">puts</span>(<span class="pl-s">"Full"</span>);
            <span class="pl-k">return</span>;
        }
    
        <span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>] <span class="pl-c1">=</span> <span class="pl-en">malloc</span>(<span class="pl-c1">0x80</span>);
        <span class="pl-en">printf</span>(<span class="pl-s">"Data: "</span>);
        <span class="pl-smi">ssize_t</span> <span class="pl-s1">len</span> <span class="pl-c1">=</span> <span class="pl-en">read</span>(<span class="pl-c1">0</span>, <span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>], <span class="pl-c1">0x7f</span>);
        <span class="pl-k">if</span> (<span class="pl-s1">len</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>][<span class="pl-s1">len</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>] <span class="pl-c1">=</span> <span class="pl-c1">'\0'</span>;
    }
    
    <span class="pl-smi">void</span> <span class="pl-en">delete_note</span>() {
        <span class="pl-smi">int</span> <span class="pl-s1">idx</span>;
        <span class="pl-en">printf</span>(<span class="pl-s">"Index: "</span>);
        <span class="pl-en">scanf</span>(<span class="pl-s">"%d"</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">idx</span>);
        <span class="pl-k">if</span> (<span class="pl-s1">idx</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> <span class="pl-c1">||</span> <span class="pl-s1">idx</span> &gt;= <span class="pl-c1">8</span> <span class="pl-c1">||</span> !<span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>]) {
            <span class="pl-en">puts</span>(<span class="pl-s">"Invalid"</span>);
            <span class="pl-k">return</span>;
        }
        <span class="pl-en">free</span>(<span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>]);
        <span class="pl-en">puts</span>(<span class="pl-s">"Freed!"</span>);
    }
    
    <span class="pl-smi">void</span> <span class="pl-en">show_note</span>() {
        <span class="pl-smi">int</span> <span class="pl-s1">idx</span>;
        <span class="pl-en">printf</span>(<span class="pl-s">"Index: "</span>);
        <span class="pl-en">scanf</span>(<span class="pl-s">"%d"</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">idx</span>);
        <span class="pl-k">if</span> (<span class="pl-s1">idx</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> <span class="pl-c1">||</span> <span class="pl-s1">idx</span> &gt;= <span class="pl-c1">8</span> <span class="pl-c1">||</span> !<span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>]) {
            <span class="pl-en">puts</span>(<span class="pl-s">"Invalid"</span>);
            <span class="pl-k">return</span>;
        }
        <span class="pl-en">printf</span>(<span class="pl-s">"Data: %s\n"</span>, <span class="pl-s1">notes</span>[<span class="pl-s1">idx</span>]);
    }
    
    <span class="pl-smi">int</span> <span class="pl-en">main</span>() {
        <span class="pl-en">setbuf</span>(<span class="pl-s1">stdout</span>, <span class="pl-c1">NULL</span>);
        <span class="pl-smi">int</span> <span class="pl-s1">choice</span>;
        <span class="pl-k">while</span> (<span class="pl-c1">1</span>) {
            <span class="pl-en">puts</span>(<span class="pl-s">"1. Add"</span>);
            <span class="pl-en">puts</span>(<span class="pl-s">"2. Delete"</span>);
            <span class="pl-en">puts</span>(<span class="pl-s">"3. Show"</span>);
            <span class="pl-en">puts</span>(<span class="pl-s">"4. Exit"</span>);
            <span class="pl-en">scanf</span>(<span class="pl-s">"%d"</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">choice</span>);
            <span class="pl-en">getchar</span>();
            <span class="pl-k">switch</span> (<span class="pl-s1">choice</span>) {
                <span class="pl-k">case</span> <span class="pl-c1">1</span>: <span class="pl-en">add_note</span>(); <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">2</span>: <span class="pl-en">delete_note</span>(); <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">3</span>: <span class="pl-en">show_note</span>(); <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">4</span>: <span class="pl-en">exit</span>(<span class="pl-c1">0</span>);
                <span class="pl-k">default</span>: <span class="pl-en">puts</span>(<span class="pl-s">"Invalid"</span>); <span class="pl-k">break</span>;
            }
        }
    }</pre>
 </div>
 <p dir="auto">
  Для компиляции без защитных механизмов используем следующие флаги:
 </p>
 <div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto">
  <pre>gcc -g -o uaf uaf.c -no-pie -fno-stack-protector</pre>
 </div>
 <ul dir="auto">
  <li>
   <strong>
    -g
   </strong>
   — включение отладочной информации для
   <strong>
    GDB
   </strong>
   ;
  </li>
  <li>
   <strong>
    -no-pie
   </strong>
   — отключение позиционно-независимого исполнения (чтобы адреса в памяти были
            фиксированы);
  </li>
  <li>
   <strong>
    -fno-stack-protector
   </strong>
   — отключение защиты стека от переполнения.
  </li>
 </ul>
 <div class="markdown-heading" dir="auto">
  <h4 class="heading-element" dir="auto" tabindex="-1">
   Особенности реализации и поведение во время выполнения
  </h4>
 </div>
 <p dir="auto">
  В представленном коде указатель, полученный при вызове функции
  <code>
   malloc()
  </code>
  , сохраняется в
        массив
  <code>
   notes[]
  </code>
  , где каждая ячейка представляет собой независимую запись. Когда пользователь
        выбирает опцию удаления записи, вызывается функция
  <code>
   free()
  </code>
  , освобождающая соответствующую область
        памяти. Однако после этого сам указатель в массиве остаётся без изменений, он продолжает указывать на уже
        недействительный участок памяти. Такая логика становится источником потенциально опасного поведения.
 </p>
 <p dir="auto">
  После освобождения памяти программа по-прежнему позволяет обратиться к тому же индексу в массиве с
        помощью функции
  <code>
   show_note()
  </code>
  , которая выводит содержимое по указанному указателю. С технической
        точки зрения, обращение к освобождённой памяти не вызывает немедленного сбоя — она по-прежнему может содержать
        старые данные, особенно если с момента освобождения в этот участок ещё не была записана новая информация. Однако
        это уже нарушает корректную работу с динамической памятью, поскольку фактически программа читает из области,
        которой она больше не владеет.
 </p>
 <p dir="auto">
  Особенно интересным является поведение, при котором в дальнейшем происходит новое выделение памяти
        такого же размера, как и ранее освобождённая область. Аллокатор может принять решение выделить память из той же
        самой области, тем самым возвращая указатель, идентичный тому, что уже хранится в массиве. Таким образом, старый
        указатель начинает указывать на новые данные, что приводит к чтению непредсказуемой информации.
 </p>
 <p dir="auto">
  Такой сценарий демонстрирует характерную реализацию уязвимости типа
  <strong>
   Use-After-Free
  </strong>
  :
        программа обращается к освобождённой памяти, которая может быть повторно использована при последующих вызовах
  <code>
   malloc()
  </code>
  . Визуально поведение может оставаться корректным и даже полезным на этапе отладки, однако
        с точки зрения безопасности это создаёт серьёзную угрозу. Содержимое, доступное через такой dangling-указатель,
        может быть неожиданным, устаревшим или принадлежать другому объекту. Более того, это может привести к утечке
        конфиденциальной информации или нарушению логики работы, если освобождённый и переиспользованный участок будет
        интерпретироваться некорректно.
 </p>
 <p dir="auto">
  Подобные ошибки часто оказываются незаметными при поверхностном тестировании, поскольку не приводят к
        моментальному сбою программы. Однако в контексте безопасности, особенно в системах с многопоточностью, сетевым
        взаимодействием или при наличии доверенных данных, передаваемых через указатели, подобные недочёты становятся
        уязвимостями, которые могут быть использованы злоумышленниками.
 </p>
 <p dir="auto">
  Чтобы наглядно продемонстрировать данную уязвимость откроем uaf в отладчике GDB с включённым pwndbg.
 </p>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/UAF/1.png" rel="noopener noreferrer" target="_blank">
   <img alt="" src="https://github.com/isohise/kk/raw/main/UAF/1.png" style="max-width: 100%;"/>
  </a>
 </p>
 <p dir="auto">
  Сначала в
  <code>
   notes[0]
  </code>
  записываем строку, затем освобождаем память. После этого в
  <code>
   notes[1]
  </code>
  записываем новые данные,
  <code>
   malloc
  </code>
  повторно использует тот же участок памяти..
 </p>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/UAF/2.png" rel="noopener noreferrer" target="_blank">
   <img alt="" src="https://github.com/isohise/kk/raw/main/UAF/2.png" style="max-width: 100%;"/>
  </a>
 </p>
 <p dir="auto">
  Проверка через GDB показывает, что
  <code>
   notes[0]
  </code>
  и
  <code>
   notes[1]
  </code>
  указывают на один и
        тот же адрес, что подтверждает факт использования освобождённой памяти — классическая ситуация
  <strong>
   UAF
  </strong>
  .
 </p>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/UAF/3.png" rel="noopener noreferrer" target="_blank">
   <img alt="" src="https://github.com/isohise/kk/raw/main/UAF/3.png" style="max-width: 100%;"/>
  </a>
 </p>
 <p dir="auto">
  Данный пример наглядно демонстрирует, как отсутствие зануления указателя после освобождения памяти
        может привести к нежелательному поведению — в том числе, к утечке или подмене данных. Такое поведение особенно
        опасно в многошаговых логиках, где один и тот же участок памяти может быть использован для хранения различных
        критичных структур.
 </p>
 <p dir="auto">
  Для безопасного управления памятью в подобных случаях рекомендуется всегда присваивать указателю
        значение
  <code>
   NULL
  </code>
  после
  <code>
   free()
  </code>
  , а также реализовывать дополнительные проверки на этапе
        чтения и записи.
 </p>
 <div class="markdown-heading" dir="auto">
  <h2 class="heading-element" dir="auto" tabindex="-1">
   Защиты
  </h2>
 </div>
 <p dir="auto">
  Современные версии
  <strong>
   glibc
  </strong>
  используют механизм под названием
  <strong>
   tcache
  </strong>
  —
        это локальный кэш освобождённых блоков памяти для каждого потока. Он ускоряет работу
  <code>
   malloc
  </code>
  и
  <code>
   free
  </code>
  , но при этом меняет логику поведения кучи. Классические техники эксплуатации, такие как атаки
        на fastbin’ы, стали менее эффективны, но появились новые — например,
  <strong>
   tcache poisoning
  </strong>
  .
        Благодаря
  <strong>
   tcache
  </strong>
  стало проще делать такие атаки, как
  <strong>
   double free
  </strong>
  , особенно
        если всё происходит в рамках одного потока.
 </p>
 <p dir="auto">
  Кроме того, на этапе компиляции включаются дополнительные защиты:
  <strong>
   PIE
  </strong>
  ,
  <strong>
   NX
  </strong>
  ,
  <strong>
   RELRO
  </strong>
  и
  <strong>
   stack protector
  </strong>
  .
  <strong>
   PIE
  </strong>
  делает
        адреса кода и данных непредсказуемыми,
  <strong>
   NX
  </strong>
  запрещает выполнение кода в области стека,
  <strong>
   RELRO
  </strong>
  защищает таблицу GOT от перезаписи, а
  <strong>
   stack protector
  </strong>
  обнаруживает
        попытки переполнения буфера. Все эти механизмы делают эксплуатацию сложнее, особенно для начинающих.
 </p>
 <p dir="auto">
  Поэтому, если задача создаётся для изучения уязвимости или для демонстрации, такие защиты обычно
        отключают. Например, убирают
  <strong>
   PIE
  </strong>
  , чтобы адреса были фиксированными, отключают
  <strong>
   stack
            protector
  </strong>
  и
  <strong>
   NX
  </strong>
  , чтобы не мешали работе эксплойта, а также могут оставить
  <strong>
   RELRO
  </strong>
  в частичном режиме или вовсе отключить. Это позволяет сосредоточиться именно на сути
        уязвимости и её поведении в памяти.
 </p>
 <div class="markdown-heading" dir="auto">
  <h2 class="heading-element" dir="auto" tabindex="-1">
   Заключение
  </h2>
 </div>
 <p dir="auto">
  <strong>
   Use-After-Free
  </strong>
  — одна из наиболее интересных и опасных уязвимостей в
        heap-эксплуатации. Она требует глубокого понимания работы аллокатора, но при этом даёт широкие возможности для
        креативной эксплуатации.
 </p>
 <p dir="auto">
  С помощью
  <strong>
   GDB
  </strong>
  ,
  <strong>
   pwndbg
  </strong>
  и хорошей подготовки можно не только находить,
        но и использовать такие уязвимости, развивая навыки реверса и бинарного анализа.
 </p>
</article>
