<article class="markdown-body entry-content container-lg" itemprop="text">
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   <strong>
    Авторизация через SSH: как устроен SSH-сервер,
                ключи аутентификации и PAM-аутентификация
   </strong>
  </h3>
 </div>
 <p dir="auto">
  SSH (Secure Shell) — один из важнейших инструментов для удалённого управления серверами и рабочими
        станциями. При использовании SSH все данные, передаваемые между клиентом и сервером, шифруются, что защищает от
        подслушивания и атак «человек посередине». Здесь мы рассмотрим, как именно устроен SSH-сервер, в чём заключается
        суть ключей аутентификации, а также объясним, какую роль играет PAM-аутентификация в среде SSH.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   1. Краткая история и предназначение SSH
  </h3>
 </div>
 <p dir="auto">
  Изначально, до появления SSH, многие администраторы использовали Telnet или rsh (remote shell).
        Основная проблема этих протоколов заключалась в том, что данные, включая пароли, передавались в открытом виде.
        Это означало, что любой, кто имел доступ к сети, мог потенциально увидеть данные проходящего сеанса.
 </p>
 <p dir="auto">
  SSH был создан в 1995 году, его целью было обеспечить надёжный и защищённый способ подключения к
        удалённому терминалу. Со временем SSH стал стандартом де-факто для безопасного управления Unix-подобными
        системами, а также часто используется и в Windows-средах (через сторонние программы или встроенный клиент,
        начиная с Windows 10).
 </p>
 <p dir="auto">
  Документация по современному протоколу SSH (версия 2) описана в нескольких RFC, среди которых:
 </p>
 <ul dir="auto">
  <li>
   <a href="https://datatracker.ietf.org/doc/html/rfc4251" rel="nofollow">
    RFC 4251
   </a>
   (общее описание
            архитектуры),
  </li>
  <li>
   <a href="https://datatracker.ietf.org/doc/html/rfc4252" rel="nofollow">
    RFC 4252
   </a>
   (аутентификация),
  </li>
  <li>
   <a href="https://datatracker.ietf.org/doc/html/rfc4253" rel="nofollow">
    RFC 4253
   </a>
   (транспортный уровень),
  </li>
  <li>
   <a href="https://datatracker.ietf.org/doc/html/rfc4254" rel="nofollow">
    RFC 4254
   </a>
   (механизм каналов).
  </li>
 </ul>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   2. Общая архитектура SSH-сервера
  </h3>
 </div>
 <p dir="auto">
  Наиболее распространённая реализация SSH —
  <strong>
   OpenSSH
  </strong>
  , изначально разработанная проектом
        OpenBSD. Она включает в себя несколько компонентов, но главным для нас будет серверный демон, обычно называемый
  <code>
   sshd
  </code>
  . В большинстве современных Linux-дистрибутивов этот демон запускается как системная служба и
        прослушивает TCP-порт (по умолчанию 22) на предмет входящих соединений.
 </p>
 <p dir="auto">
  При запуске SSH-сессии на стороне клиента (например, при вводе команды
  <code>
   ssh user@host
  </code>
  ):
 </p>
 <ol dir="auto">
  <li>
   <strong>
    Устанавливается транспортный уровень
   </strong>
   : клиент и сервер обмениваются приветственными
            сообщениями, согласовывают версию протокола (в наше время почти всегда SSH-2).
  </li>
  <li>
   <strong>
    Происходит обмен ключами (Key Exchange, или KEX)
   </strong>
   : стороны договариваются об алгоритме
            шифрования (часто это варианты на основе Diffie-Hellman или Curve25519), вырабатывается сессионный ключ.
            Сервер отправляет свой хост-ключ, по которому клиент может удостовериться, что «разговаривает» именно с
            нужной машиной, а не с подменённым узлом.
  </li>
  <li>
   <strong>
    Аутентификация
   </strong>
   : клиент представляет доказательства своей подлинности — это может быть
            пароль, ключ, либо более сложная схема с привлечением PAM, двухфакторной аутентификации и т. д.
  </li>
  <li>
   <strong>
    Открываются каналы
   </strong>
   : после успешного входа внутри зашифрованного сеанса создаётся
            виртуальный канал, в котором можно запустить интерактивную оболочку (shell), выполнять команды, копировать
            файлы через SCP/SFTP, организовать туннели и т. д.
  </li>
 </ol>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   3. Ключи аутентификации и их преимущества
  </h3>
 </div>
 <p dir="auto">
  Одним из наиболее надёжных способов подтверждения подлинности пользователя в SSH считается
        аутентификация по ключам. Суть состоит в наличии у клиента пары ключей:
  <strong>
   приватный
  </strong>
  (частный)
        ключ хранится на машине пользователя и должен быть известен только ему, а
  <strong>
   публичный
  </strong>
  ключ
        размещается на сервере.
 </p>
 <p dir="auto">
  Как это работает на практике:
 </p>
 <ol dir="auto">
  <li>
   <strong>
    Генерация ключа
   </strong>
   : На локальном компьютере пользователь запускает, к примеру,
   <code>
    ssh-keygen -t rsa -b 4096
   </code>
   , либо
   <code>
    ssh-keygen -t ed25519
   </code>
   , в результате чего
            формируется пара файлов. Приватный ключ (например, id_rsa) крайне важно хранить в секрете. Публичный ключ
            (например,
   <code>
    id\_rsa.pub
   </code>
   ) можно копировать на сервер.
  </li>
 </ol>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/generate.png" rel="noopener noreferrer" target="_blank">
   <img alt="Генерация ключа" src="https://github.com/isohise/kk/raw/main/generate.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ol dir="auto" start="2">
  <li>
   <strong>
    Копирование ключа
   </strong>
   : В домашней директории пользователя на сервере есть каталог
   <code>
    ~/.ssh
   </code>
   , где расположен файл
   <code>
    authorized\_keys
   </code>
   . Туда добавляется содержимое вашего
            публичного ключа. Можно сделать это вручную или воспользоваться утилитой
   <code>
    ssh-copy-id
   </code>
   .
  </li>
 </ol>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/add.png" rel="noopener noreferrer" target="_blank">
   <img alt="Копирование ключа" src="https://github.com/isohise/kk/raw/main/add.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ol dir="auto" start="3">
  <li>
   <strong>
    Процесс аутентификации
   </strong>
   : Когда клиент инициирует SSH-подключение, сервер видит, что для
            учётной записи есть публичный ключ. Он посылает клиенту случайную строку (challenge), зашифрованную
            публичным ключом пользователя. Если на стороне клиента есть соответствующий приватный ключ, он может
            расшифровать строку и отправить правильный ответ. Таким образом, сервер убеждается, что пользователь
            действительно владеет приватным ключом.
  </li>
 </ol>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/login.png" rel="noopener noreferrer" target="_blank">
   <img alt="Аутентификация" src="https://github.com/isohise/kk/raw/main/login.png" style="max-width: 100%;"/>
  </a>
 </p>
 <p dir="auto">
  Основное преимущество такого подхода —
  <strong>
   сложность взлома
  </strong>
  . Длина SSH-ключа (2048 и
        более бит) делает перебор практически нереалистичным для современных вычислительных мощностей. Кроме того, по
        ключу удобно работать в автоматизированных сценариях (деплой, скрипты резервного копирования и т. п.): не
        требуется интерактивный ввод пароля.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   4. Обзор основных настроек SSH-сервера
  </h3>
 </div>
 <p dir="auto">
  Файл, в котором задаются основные параметры работы
  <code>
   sshd
  </code>
  , обычно находится по пути
  <code>
   /etc/ssh/sshd\_config
  </code>
  . Примеры важных опций:
 </p>
 <ul dir="auto">
  <li>
   <strong>
    Port
   </strong>
   : указывает, на каком TCP-порту будет слушать
   <code>
    sshd
   </code>
   . По умолчанию 22, но
            многие администраторы меняют его, чтобы снизить количество автоматических попыток взлома.
  </li>
 </ul>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/1.png" rel="noopener noreferrer" target="_blank">
   <img alt="Port" src="https://github.com/isohise/kk/raw/main/1.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ul dir="auto">
  <li>
   <strong>
    PermitRootLogin
   </strong>
   : разрешает или запрещает прямой вход под пользователем
   <code>
    root
   </code>
   .
            Часто ставят no для повышения безопасности.
  </li>
 </ul>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/2.png" rel="noopener noreferrer" target="_blank">
   <img alt="PermitRootLogin" src="https://github.com/isohise/kk/raw/main/2.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ul dir="auto">
  <li>
   <strong>
    PubkeyAuthentication
   </strong>
   и
   <strong>
    PasswordAuthentication
   </strong>
   : включают или отключают вход
            по ключам и паролю соответственно.
  </li>
 </ul>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/4.png" rel="noopener noreferrer" target="_blank">
   <img alt="PasswordAuthentication" src="https://github.com/isohise/kk/raw/main/4.png" style="max-width: 100%;"/>
  </a>
  <a href="https://github.com/isohise/kk/blob/main/3.png" rel="noopener noreferrer" target="_blank">
   <img alt="PubkeyAuthentication" src="https://github.com/isohise/kk/raw/main/3.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ul dir="auto">
  <li>
   <strong>
    AuthorizedKeysFile
   </strong>
   : определяет, где искать публичные ключи пользователей (по умолчанию
   <code>
    ~/.ssh/authorized\_keys
   </code>
   ).
  </li>
 </ul>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/5.png" rel="noopener noreferrer" target="_blank">
   <img alt="AuthorizedKeysFile" src="https://github.com/isohise/kk/raw/main/5.png" style="max-width: 100%;"/>
  </a>
 </p>
 <ul dir="auto">
  <li>
   <strong>
    KbdInteractiveAuthentication
   </strong>
   : активирует механизмы, задействующие PAM или иные методы
            аутентификации.
  </li>
 </ul>
 <p dir="auto">
  <a href="https://github.com/isohise/kk/blob/main/6.png" rel="noopener noreferrer" target="_blank">
   <img alt="AuthorizedKeysFile" src="https://github.com/isohise/kk/raw/main/6.png" style="max-width: 100%;"/>
  </a>
 </p>
 <p dir="auto">
  После изменения параметров в
  <code>
   sshd\_config
  </code>
  нужно перезапустить службу (например,
  <code>
   sudo systemctl restart sshd
  </code>
  в системах с systemd). Подробное описание каждой настройки можно найти
        в документации OpenSSH, а также через команду man
  <code>
   sshd\_config
  </code>
  .
 </p>
 <p dir="auto">
  Дополнительно многие операционные системы ведут логи, связанные с SSH, в файлах вроде
  <code>
   /var/log/auth.log
  </code>
  или
  <code>
   /var/log/secure
  </code>
  . Там видны сведения о том, кто когда заходил,
        были ли попытки неправильного пароля и т. п.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   5. Что такое PAM и зачем он нужен?
  </h3>
 </div>
 <p dir="auto">
  <strong>
   PAM (Pluggable Authentication Modules)
  </strong>
  — это модульная система аутентификации в
        Unix-подобных ОС. Она позволяет гибко настроить, как именно должны проверяться учетные данные пользователя. При
        работе с SSH PAM открывает путь к дополнительным возможностям:
 </p>
 <ol dir="auto">
  <li>
   <strong>
    Аутентификация с помощью пароля
   </strong>
   : PAM может сверяться с локальными базами паролей
            (
   <code>
    /etc/shadow
   </code>
   ), LDAP, Kerberos и другими внешними сервисами.
  </li>
  <li>
   <strong>
    Двухфакторная аутентификация
   </strong>
   : с помощью PAM-модулей можно подключить проверку одноразовых
            паролей (TOTP), SMS-коды и др.
  </li>
  <li>
   <strong>
    Ограничения на время и место
   </strong>
   : PAM-модули могут не пускать пользователей, если они пытаются
            войти в неподходящее время суток или с нежелательного IP-адреса.
  </li>
 </ol>
 <p dir="auto">
  При входе по SSH, когда пользователь указывает пароль, демон
  <code>
   sshd
  </code>
  часто делегирует
        проверку этого пароля системе PAM. То есть
  <code>
   sshd
  </code>
  говорит: «Пожалуйста, проверь эти учетные данные, а
        я подожду ответа — пускать или нет?» В результате администратор может тонко регулировать правила доступа, не
        меняя самого кода OpenSSH, а лишь корректируя конфигурацию PAM.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   6. Как работает PAM-аутентификация в SSH
  </h3>
 </div>
 <p dir="auto">
  При включенном параметре
  <code>
   UsePAM yes
  </code>
  в
  <code>
   sshd\_config
  </code>
  сервер SSH
        взаимодействует с PAM в соответствии с правилами, определёнными в файлах конфигурации, обычно лежащих в
  <code>
   /etc/pam.d/
  </code>
  . Там могут находиться строки вида:
 </p>
 <div class="snippet-clipboard-content notranslate position-relative overflow-auto">
  <pre class="notranslate"><code>
    auth       required     pam\_sepermit.so
    
    auth       include      password-auth
    
    account    required     pam\_nologin.so
    
    account    include      password-auth
    
    ...
    
    </code></pre>
 </div>
 <p dir="auto">
  Эти строки означают, какие модули нужно запускать для аутентификации (
  <code>
   auth
  </code>
  ), какие для
        проверки учётной записи (
  <code>
   account
  </code>
  ) и так далее. PAM-модули могут:
 </p>
 <ul dir="auto">
  <li>
   Проверять пароль в
   <code>
    /etc/shadow
   </code>
   .
  </li>
  <li>
   Сверяться с внешним сервером (LDAP или RADIUS).
  </li>
  <li>
   Выполнять дополнительный скрипт, например, для записи лога или проверок на предмет блокировки учётной
            записи.
  </li>
 </ul>
 <p dir="auto">
  Благодаря PAM появляется возможность, например, задействовать Google Authenticator (TOTP), не меняя
  <code>
   sshd
  </code>
  на уровне исходного кода. Достаточно установить соответствующий пакет и прописать нужный
        PAM-модуль в конфигурации. При очередном входе сервер SSH попросит ввести не только пароль, но и одноразовый код
        из приложения на смартфоне.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   7. Режимы и механизмы аутентификации в SSH
  </h3>
 </div>
 <p dir="auto">
  SSH предлагает несколько механизмов проверки личности пользователя:
 </p>
 <ol dir="auto">
  <li>
   <strong>
    Парольная аутентификация (PasswordAuthentication)
   </strong>
   . Пользователь вводит пароль, который
            передаётся на сервер в зашифрованном виде. Сервер, в зависимости от настроек, может проверять пароль
            локально (через
   <code>
    /etc/shadow
   </code>
   ) или передавать его PAM-модулям для дальнейшей валидации (LDAP,
            Kerberos, RADIUS и т. д.).
  </li>
  <li>
   <strong>
    Аутентификация по ключу (PubkeyAuthentication)
   </strong>
   . Более безопасный метод, когда на клиенте
            хранится приватный ключ, а на сервере — соответствующий публичный ключ (в
   <code>
    ~/.ssh/authorized_keys
   </code>
   ). При подключении сервер шифрует случайные данные публичным ключом и
            требует у клиента правильный ответ, который может дать только владелец приватного ключа.
  </li>
  <li>
   <strong>
    Клавиатурно-интерактивная аутентификация (Keyboard-Interactive)
   </strong>
   . Гибкая схема, которая
            может быть настроена по-разному — от простого ввода пароля (вопрос-ответ) до сложного взаимодействия с PAM
            (например, двухфакторная аутентификация). Сервер может присылать набор «вопросов», а клиент в интерактивном
            режиме передаёт «ответы». По сути, этот механизм тоже часто используют для вызова PAM или других
            дополнительных проверок.
  </li>
  <li>
   <strong>
    GSSAPI
   </strong>
   . Используется в корпоративных окружениях и базируется на Kerberos для единого входа
            (Single Sign-On). Позволяет пользователям, уже прошедшим аутентификацию в домене (Kerberos-реалм),
            подключаться к серверам без повторного ввода пароля или ключа.
  </li>
  <li>
   <strong>
    Host-Based
   </strong>
   Редко используемая в публичных сетях схема, при которой аутентификация идёт не
            только на уровне учётной записи пользователя, но и проверяется доверие к хосту-клиенту (сравнивается ключ
            «хоста»). Это может быть полезно в строго контролируемых внутрикорпоративных сетях, но в большинстве случаев
            популярностью не пользуется.
  </li>
 </ol>
 <p dir="auto">
  В современных конфигурациях SSH чаще всего применяют два первых способа (пароль и ключ), а в более
        продвинутых сценариях добавляют GSSAPI или двухфакторную аутентификацию на базе PAM через механизм
        keyboard-interactive. Такой набор методов соответствует тому, что описывается в официальных руководствах по SSH
        и в других источниках, в том числе и по ссылке из вопроса.
 </p>
 <p dir="auto">
  Для повышения общей надёжности многие администраторы запрещают использование паролей вовсе
        (устанавливая
  <code>
   PasswordAuthentication no
  </code>
  ) и разрешают лишь вход по ключам. Это существенно снижает
        риск брутфорса или угадывания пароля.
 </p>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   8. Практические советы по настройке SSH и PAM
  </h3>
 </div>
 <ul dir="auto">
  <li>
   <strong>
    Отключайте неиспользуемые способы входа
   </strong>
   . Если нет необходимости в GSSAPI или каких-то
            экзотических механизмах, лучше отключить их в
   <code>
    sshd\_config
   </code>
   . Это сузит потенциальную поверхность
            атаки.
  </li>
  <li>
   <strong>
    Используйте сильные ключи
   </strong>
   . Если вы выбираете RSA, берите ключи длиной не менее 2048 или
            даже 4096 бит. Также популярны Ed25519-ключи, которые короче и обычно считаются безопасными и
            быстродействующими.
  </li>
  <li>
   <strong>
    Не используйте пароль root
   </strong>
   .
   <code>
    PermitRootLogin no
   </code>
   — один из главных постулатов
            безопасности. Либо разрешайте root-вход только по ключу, если очень нужно.
  </li>
  <li>
   <strong>
    Следите за логами
   </strong>
   . В файлах
   <code>
    /var/log/auth.log
   </code>
   ,
   <code>
    /var/log/secure
   </code>
   или эквивалентных видно, какие IP пытались подключаться и какие ошибки при этом возникали.
  </li>
  <li>
   <strong>
    Fail2ban или аналоги
   </strong>
   . Инструменты вроде
   <a href="https://www.fail2ban.org/" rel="nofollow">
    Fail2ban
   </a>
   анализируют логи и блокируют IP-адреса, пытающиеся многократно подобрать
            пароль. Это особенно полезно, если парольный вход не отключён полностью.
  </li>
  <li>
   <strong>
    PAM-модули
   </strong>
   . Если хотите добавить двухфакторную аутентификацию, создайте резервное
            копирование сеансов или сделать иной нестандартный сценарий, изучите возможности PAM. Достаточно установить
            нужный модуль и прописать пару строк в конфигурации, чтобы сервер SSH начал запрашивать дополнительные
            данные.
  </li>
 </ul>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   9. Распространённые заблуждения
  </h3>
 </div>
 <ul dir="auto">
  <li>
   <strong>
    «SSH полностью неуязвим»
   </strong>
   : на самом деле любой сервис может содержать уязвимости, если не
            обновляться или использовать слабые конфигурации (например, слишком короткие ключи, доступ root с простым
            паролем и т. д.).
  </li>
  <li>
   <strong>
    «Достаточно сменить порт 22»
   </strong>
   : перенос SSH на непопулярный порт (например, 2222)
            действительно уменьшает количество автоматических сканирований, но не является полноценной мерой
            безопасности. Лучше сочетать это с другими подходами — ключами, Fail2ban, запретом root-доступа.
  </li>
  <li>
   <strong>
    «PAM— это только про пароли»
   </strong>
   : PAM позволяет интегрировать самые разные схемы. Он может
            проверять биометрию, чиповые карты, токены TOTP и т. д.
  </li>
 </ul>
 <hr/>
 <div class="markdown-heading" dir="auto">
  <h3 class="heading-element" dir="auto" tabindex="-1">
   Заключение
  </h3>
 </div>
 <p dir="auto">
  SSH остаётся одним из важнейших инструментов для удалённого управления. В основе его работы лежат
        надёжные криптографические механизмы и продуманная архитектура с разделением на транспорт, аутентификацию и
        каналы для сессий. Демон sshd предоставляет гибкие возможности настройки: можно выбирать разные алгоритмы
        шифрования, методы подтверждения личности (пароли, ключи, Kerberos и др.), а также подключать модули PAM,
        которые открывают дополнительный простор для интеграции с внешними сервисами и усиления безопасности.
 </p>
 <p dir="auto">
  Чтобы получить максимально безопасную конфигурацию, стоит ориентироваться на ряд принципов:
 </p>
 <ul dir="auto">
  <li>
   Предпочитать аутентификацию по ключу, а не по паролю.
  </li>
  <li>
   Не давать пользователю root входить напрямую по паролю.
  </li>
  <li>
   Следить за логами и применять механизмы вроде Fail2ban, если система не располагается в полностью доверенной
            среде.
  </li>
  <li>
   Изучить возможности PAM, чтобы при необходимости подключить многофакторную аутентификацию или иные методы
            проверки личности.
  </li>
 </ul>
 <p dir="auto">
  Дополнительную информацию можно найти в
  <a href="https://www.openssh.com/manual.html" rel="nofollow">
   официальной документации OpenSSH
  </a>
  , а также в локальных руководствах по командам
  <code>
   man sshd
  </code>
  и
  <code>
   man sshd\_config
  </code>
  . Если работать с учётом этих рекомендаций, SSH будет
        оставаться надёжным средством администрирования и защищённого доступа в самых разных сценариях, от локальных
        сетей до крупных облачных инфраструктур.
 </p>
</article>
